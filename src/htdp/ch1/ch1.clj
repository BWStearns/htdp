(ns htdp.ch1)

(comment
  "Skipping all of the exercises for which the answer is not a function. This
  is to enable testing. Maybe I'll go back and add maps of {ex# ans} later?")

(defn f->c [t]
  "Ex 2.2.1"
  (/ (- t 32) 1.8))

(defn dollar->euro [d]
  "Ex 2.2.2"
  (* d 0.89))

(defn triangle [b h]
  "Ex 2.2.3"
  (/ (* b h) 2))

(defn convert3 [ones tens hundreds]
  "Ex 2.2.4"
  (+ (* 100 hundreds)
     (* 10 tens)
     ones))

(defn tax [gross]
  "Ex 2.3.1"
  (* gross 0.15))

(defn net [hours]
  "Ex 2.3.1"
  (let [gross (* hours 12)]
    (- gross (tax gross))))

(defn sum-coins [counts]
  "Ex 2.3.2"
  (reduce-kv (fn [total value n] (+ total (* value n)))
             0
             (zipmap [1 5 10 25] counts)))

(defn total-profit [n]
  "Ex 2.3.3"
  (- (* 4.5 n) 20))

;; The functions for the movie theater examples

(defn attendees [ticket-price]
  "Ex 3.1.3-4"
  (+ 120
     (* (/ 15 0.10) (- 5 ticket-price))))

(defn cost [ticket-price]
  "Ex 3.1.3-4"
  (+ 180 (* 0.04 (attendees ticket-price))))

(defn revenue [ticket-price]
  "Ex 3.1.3-4"
  (* (attendees ticket-price) ticket-price))

(defn profit [ticket-price]
  "Ex 3.1.3-4"
  (- (revenue ticket-price)
     (cost ticket-price)))

(defn in->cm [in]
  "Ex 3.3.1"
  (* 2.54 in))

(defn ft->in [ft]
  "Ex 3.3.1"
  (* 12 ft))

(defn yd->ft [yd]
  "Ex 3.3.1"
  (* yd 3))

(defn rd->yd [rd]
  "Ex 3.3.1"
  (* 5.5 rd))

(defn fl->rd [fl]
  "Ex 3.3.1"
  (* 40 fl))

(defn mi->fl [mi]
  "Ex 3.3.1"
  (* 8 mi))

(def ft->cm
  "Ex 3.3.1"
  (comp ft->in in->cm))

(def yd->cm
  "Ex 3.3.1"
  (comp yd->ft ft->cm))

(def rd->in
  "Ex 3.3.1"
  (comp rd->yd yd->ft ft->in))

(def mi->ft
  "Ex 3.3.1"
  (comp mi->fl fl->rd rd->yd yd->ft))



(def PI 3.1419)

(defn area-circle [r]
  (* PI (* r r)))

(defn perimeter-circle [r]
  (* 2 PI r))

(defn vol-cylinder [r h]
  (* h (area-circle r)))

(defn area-ring [inner outer]
  (- (area-circle outer)
     (area-circle inner)))

(defn area-pipe [inner-r h thickness]
  (let [outer-r (+ inner-r thickness)]
    (+ (* 2 (area-ring inner-r outer-r))
       (* h (perimeter-circle inner-r))
       (* h (perimeter-circle outer-r)))))

(defn area-cylinder [r h]
  (area-pipe 0 h r))

(defn rocket-height [g t]
  (* 0.5 g t t))




(defn f-by-g [f g]
  (comment "
    Using Haskell notation: ([a] -> a) -> (b -> a) -> ([b] -> b) => a -> Key-able

    Example use:
      (def max-by-area (f-by-g max area))

    Maybe think of f as a selection function that operates on a collection
    generated by g? I need to write a better description")
  (fn [coll]
    (let [kv (zipmap (map g coll) coll)]
      (get kv (apply f (keys kv))))))
